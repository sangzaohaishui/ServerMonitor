// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: processmon.proto

#ifndef PROTOBUF_processmon_2eproto__INCLUDED
#define PROTOBUF_processmon_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_processmon_2eproto();
void protobuf_AssignDesc_processmon_2eproto();
void protobuf_ShutdownFile_processmon_2eproto();

class MonLogMSG;

// ===================================================================

class MonLogMSG : public ::google::protobuf::Message {
 public:
  MonLogMSG();
  virtual ~MonLogMSG();

  MonLogMSG(const MonLogMSG& from);

  inline MonLogMSG& operator=(const MonLogMSG& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MonLogMSG& default_instance();

  void Swap(MonLogMSG* other);

  // implements Message ----------------------------------------------

  MonLogMSG* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MonLogMSG& from);
  void MergeFrom(const MonLogMSG& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes sHost = 1;
  inline bool has_shost() const;
  inline void clear_shost();
  static const int kSHostFieldNumber = 1;
  inline const ::std::string& shost() const;
  inline void set_shost(const ::std::string& value);
  inline void set_shost(const char* value);
  inline void set_shost(const void* value, size_t size);
  inline ::std::string* mutable_shost();
  inline ::std::string* release_shost();
  inline void set_allocated_shost(::std::string* shost);

  // optional bytes sProcess = 2;
  inline bool has_sprocess() const;
  inline void clear_sprocess();
  static const int kSProcessFieldNumber = 2;
  inline const ::std::string& sprocess() const;
  inline void set_sprocess(const ::std::string& value);
  inline void set_sprocess(const char* value);
  inline void set_sprocess(const void* value, size_t size);
  inline ::std::string* mutable_sprocess();
  inline ::std::string* release_sprocess();
  inline void set_allocated_sprocess(::std::string* sprocess);

  // optional int32 log_state = 3;
  inline bool has_log_state() const;
  inline void clear_log_state();
  static const int kLogStateFieldNumber = 3;
  inline ::google::protobuf::int32 log_state() const;
  inline void set_log_state(::google::protobuf::int32 value);

  // optional int64 s_time = 4;
  inline bool has_s_time() const;
  inline void clear_s_time();
  static const int kSTimeFieldNumber = 4;
  inline ::google::protobuf::int64 s_time() const;
  inline void set_s_time(::google::protobuf::int64 value);

  // optional bytes s_info = 5;
  inline bool has_s_info() const;
  inline void clear_s_info();
  static const int kSInfoFieldNumber = 5;
  inline const ::std::string& s_info() const;
  inline void set_s_info(const ::std::string& value);
  inline void set_s_info(const char* value);
  inline void set_s_info(const void* value, size_t size);
  inline ::std::string* mutable_s_info();
  inline ::std::string* release_s_info();
  inline void set_allocated_s_info(::std::string* s_info);

  // optional int32 n_type = 6;
  inline bool has_n_type() const;
  inline void clear_n_type();
  static const int kNTypeFieldNumber = 6;
  inline ::google::protobuf::int32 n_type() const;
  inline void set_n_type(::google::protobuf::int32 value);

  // optional bytes s_data_exten = 7;
  inline bool has_s_data_exten() const;
  inline void clear_s_data_exten();
  static const int kSDataExtenFieldNumber = 7;
  inline const ::std::string& s_data_exten() const;
  inline void set_s_data_exten(const ::std::string& value);
  inline void set_s_data_exten(const char* value);
  inline void set_s_data_exten(const void* value, size_t size);
  inline ::std::string* mutable_s_data_exten();
  inline ::std::string* release_s_data_exten();
  inline void set_allocated_s_data_exten(::std::string* s_data_exten);

  // @@protoc_insertion_point(class_scope:MonLogMSG)
 private:
  inline void set_has_shost();
  inline void clear_has_shost();
  inline void set_has_sprocess();
  inline void clear_has_sprocess();
  inline void set_has_log_state();
  inline void clear_has_log_state();
  inline void set_has_s_time();
  inline void clear_has_s_time();
  inline void set_has_s_info();
  inline void clear_has_s_info();
  inline void set_has_n_type();
  inline void clear_has_n_type();
  inline void set_has_s_data_exten();
  inline void clear_has_s_data_exten();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* shost_;
  ::std::string* sprocess_;
  ::google::protobuf::int64 s_time_;
  ::google::protobuf::int32 log_state_;
  ::google::protobuf::int32 n_type_;
  ::std::string* s_info_;
  ::std::string* s_data_exten_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_processmon_2eproto();
  friend void protobuf_AssignDesc_processmon_2eproto();
  friend void protobuf_ShutdownFile_processmon_2eproto();

  void InitAsDefaultInstance();
  static MonLogMSG* default_instance_;
};
// ===================================================================


// ===================================================================

// MonLogMSG

// optional bytes sHost = 1;
inline bool MonLogMSG::has_shost() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MonLogMSG::set_has_shost() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MonLogMSG::clear_has_shost() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MonLogMSG::clear_shost() {
  if (shost_ != &::google::protobuf::internal::kEmptyString) {
    shost_->clear();
  }
  clear_has_shost();
}
inline const ::std::string& MonLogMSG::shost() const {
  return *shost_;
}
inline void MonLogMSG::set_shost(const ::std::string& value) {
  set_has_shost();
  if (shost_ == &::google::protobuf::internal::kEmptyString) {
    shost_ = new ::std::string;
  }
  shost_->assign(value);
}
inline void MonLogMSG::set_shost(const char* value) {
  set_has_shost();
  if (shost_ == &::google::protobuf::internal::kEmptyString) {
    shost_ = new ::std::string;
  }
  shost_->assign(value);
}
inline void MonLogMSG::set_shost(const void* value, size_t size) {
  set_has_shost();
  if (shost_ == &::google::protobuf::internal::kEmptyString) {
    shost_ = new ::std::string;
  }
  shost_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MonLogMSG::mutable_shost() {
  set_has_shost();
  if (shost_ == &::google::protobuf::internal::kEmptyString) {
    shost_ = new ::std::string;
  }
  return shost_;
}
inline ::std::string* MonLogMSG::release_shost() {
  clear_has_shost();
  if (shost_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = shost_;
    shost_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MonLogMSG::set_allocated_shost(::std::string* shost) {
  if (shost_ != &::google::protobuf::internal::kEmptyString) {
    delete shost_;
  }
  if (shost) {
    set_has_shost();
    shost_ = shost;
  } else {
    clear_has_shost();
    shost_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes sProcess = 2;
inline bool MonLogMSG::has_sprocess() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MonLogMSG::set_has_sprocess() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MonLogMSG::clear_has_sprocess() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MonLogMSG::clear_sprocess() {
  if (sprocess_ != &::google::protobuf::internal::kEmptyString) {
    sprocess_->clear();
  }
  clear_has_sprocess();
}
inline const ::std::string& MonLogMSG::sprocess() const {
  return *sprocess_;
}
inline void MonLogMSG::set_sprocess(const ::std::string& value) {
  set_has_sprocess();
  if (sprocess_ == &::google::protobuf::internal::kEmptyString) {
    sprocess_ = new ::std::string;
  }
  sprocess_->assign(value);
}
inline void MonLogMSG::set_sprocess(const char* value) {
  set_has_sprocess();
  if (sprocess_ == &::google::protobuf::internal::kEmptyString) {
    sprocess_ = new ::std::string;
  }
  sprocess_->assign(value);
}
inline void MonLogMSG::set_sprocess(const void* value, size_t size) {
  set_has_sprocess();
  if (sprocess_ == &::google::protobuf::internal::kEmptyString) {
    sprocess_ = new ::std::string;
  }
  sprocess_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MonLogMSG::mutable_sprocess() {
  set_has_sprocess();
  if (sprocess_ == &::google::protobuf::internal::kEmptyString) {
    sprocess_ = new ::std::string;
  }
  return sprocess_;
}
inline ::std::string* MonLogMSG::release_sprocess() {
  clear_has_sprocess();
  if (sprocess_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sprocess_;
    sprocess_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MonLogMSG::set_allocated_sprocess(::std::string* sprocess) {
  if (sprocess_ != &::google::protobuf::internal::kEmptyString) {
    delete sprocess_;
  }
  if (sprocess) {
    set_has_sprocess();
    sprocess_ = sprocess;
  } else {
    clear_has_sprocess();
    sprocess_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 log_state = 3;
inline bool MonLogMSG::has_log_state() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MonLogMSG::set_has_log_state() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MonLogMSG::clear_has_log_state() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MonLogMSG::clear_log_state() {
  log_state_ = 0;
  clear_has_log_state();
}
inline ::google::protobuf::int32 MonLogMSG::log_state() const {
  return log_state_;
}
inline void MonLogMSG::set_log_state(::google::protobuf::int32 value) {
  set_has_log_state();
  log_state_ = value;
}

// optional int64 s_time = 4;
inline bool MonLogMSG::has_s_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MonLogMSG::set_has_s_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MonLogMSG::clear_has_s_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MonLogMSG::clear_s_time() {
  s_time_ = GOOGLE_LONGLONG(0);
  clear_has_s_time();
}
inline ::google::protobuf::int64 MonLogMSG::s_time() const {
  return s_time_;
}
inline void MonLogMSG::set_s_time(::google::protobuf::int64 value) {
  set_has_s_time();
  s_time_ = value;
}

// optional bytes s_info = 5;
inline bool MonLogMSG::has_s_info() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MonLogMSG::set_has_s_info() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MonLogMSG::clear_has_s_info() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MonLogMSG::clear_s_info() {
  if (s_info_ != &::google::protobuf::internal::kEmptyString) {
    s_info_->clear();
  }
  clear_has_s_info();
}
inline const ::std::string& MonLogMSG::s_info() const {
  return *s_info_;
}
inline void MonLogMSG::set_s_info(const ::std::string& value) {
  set_has_s_info();
  if (s_info_ == &::google::protobuf::internal::kEmptyString) {
    s_info_ = new ::std::string;
  }
  s_info_->assign(value);
}
inline void MonLogMSG::set_s_info(const char* value) {
  set_has_s_info();
  if (s_info_ == &::google::protobuf::internal::kEmptyString) {
    s_info_ = new ::std::string;
  }
  s_info_->assign(value);
}
inline void MonLogMSG::set_s_info(const void* value, size_t size) {
  set_has_s_info();
  if (s_info_ == &::google::protobuf::internal::kEmptyString) {
    s_info_ = new ::std::string;
  }
  s_info_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MonLogMSG::mutable_s_info() {
  set_has_s_info();
  if (s_info_ == &::google::protobuf::internal::kEmptyString) {
    s_info_ = new ::std::string;
  }
  return s_info_;
}
inline ::std::string* MonLogMSG::release_s_info() {
  clear_has_s_info();
  if (s_info_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = s_info_;
    s_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MonLogMSG::set_allocated_s_info(::std::string* s_info) {
  if (s_info_ != &::google::protobuf::internal::kEmptyString) {
    delete s_info_;
  }
  if (s_info) {
    set_has_s_info();
    s_info_ = s_info;
  } else {
    clear_has_s_info();
    s_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 n_type = 6;
inline bool MonLogMSG::has_n_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MonLogMSG::set_has_n_type() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MonLogMSG::clear_has_n_type() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MonLogMSG::clear_n_type() {
  n_type_ = 0;
  clear_has_n_type();
}
inline ::google::protobuf::int32 MonLogMSG::n_type() const {
  return n_type_;
}
inline void MonLogMSG::set_n_type(::google::protobuf::int32 value) {
  set_has_n_type();
  n_type_ = value;
}

// optional bytes s_data_exten = 7;
inline bool MonLogMSG::has_s_data_exten() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MonLogMSG::set_has_s_data_exten() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MonLogMSG::clear_has_s_data_exten() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MonLogMSG::clear_s_data_exten() {
  if (s_data_exten_ != &::google::protobuf::internal::kEmptyString) {
    s_data_exten_->clear();
  }
  clear_has_s_data_exten();
}
inline const ::std::string& MonLogMSG::s_data_exten() const {
  return *s_data_exten_;
}
inline void MonLogMSG::set_s_data_exten(const ::std::string& value) {
  set_has_s_data_exten();
  if (s_data_exten_ == &::google::protobuf::internal::kEmptyString) {
    s_data_exten_ = new ::std::string;
  }
  s_data_exten_->assign(value);
}
inline void MonLogMSG::set_s_data_exten(const char* value) {
  set_has_s_data_exten();
  if (s_data_exten_ == &::google::protobuf::internal::kEmptyString) {
    s_data_exten_ = new ::std::string;
  }
  s_data_exten_->assign(value);
}
inline void MonLogMSG::set_s_data_exten(const void* value, size_t size) {
  set_has_s_data_exten();
  if (s_data_exten_ == &::google::protobuf::internal::kEmptyString) {
    s_data_exten_ = new ::std::string;
  }
  s_data_exten_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MonLogMSG::mutable_s_data_exten() {
  set_has_s_data_exten();
  if (s_data_exten_ == &::google::protobuf::internal::kEmptyString) {
    s_data_exten_ = new ::std::string;
  }
  return s_data_exten_;
}
inline ::std::string* MonLogMSG::release_s_data_exten() {
  clear_has_s_data_exten();
  if (s_data_exten_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = s_data_exten_;
    s_data_exten_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MonLogMSG::set_allocated_s_data_exten(::std::string* s_data_exten) {
  if (s_data_exten_ != &::google::protobuf::internal::kEmptyString) {
    delete s_data_exten_;
  }
  if (s_data_exten) {
    set_has_s_data_exten();
    s_data_exten_ = s_data_exten;
  } else {
    clear_has_s_data_exten();
    s_data_exten_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_processmon_2eproto__INCLUDED
